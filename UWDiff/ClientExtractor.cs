using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.IO;
using System.Linq;
using System.Text;

namespace UWDiff
{
    public class ClientExtractor
    {
        readonly CSharpSyntaxRewriter rewriter;

        public ClientExtractor(CSharpSyntaxRewriter rewriter)
        {
            this.rewriter = rewriter;
        }

        public ServiceFile Extract(string path)
        {
            var tree = CSharpSyntaxTree.ParseText(File.ReadAllText(path));
            var root = tree.GetRoot();

            if (rewriter != null)
            {
                root = rewriter.Visit(root);
            }

            var ns = root
                .DescendantNodes()
                .OfType<NamespaceDeclarationSyntax>()
                .First();

            var classes = root
                .DescendantNodes()
                .OfType<ClassDeclarationSyntax>()
                .Where(c =>
                {
                    if (c.Identifier.Text.EndsWithEither("Input", "Output"))
                    {
                        return true;
                    }

                    return c.BaseList?.Types.Any(b => b.Type.ToFullString().Contains("ClientBase<")) ?? false;
                });

            var ifaces = root
                .DescendantNodes()
                .OfType<InterfaceDeclarationSyntax>();

            return new ServiceFile
            {
                Namespace = ns,
                Types = ((IEnumerable<CSharpSyntaxNode>)classes).Concat(ifaces)
            };
        }
    }

    public class DisagreementRewriter : CSharpSyntaxRewriter
    {
        readonly IEnumerable<TypeDisagreement> disagreements;

        public DisagreementRewriter(IEnumerable<TypeDisagreement> disagreements)
        {
            this.disagreements = disagreements;
        }

        public override SyntaxNode VisitParameter(ParameterSyntax node)
        {
            var disagree = disagreements.FirstOrDefault(d => node.Type.ToString().EndsWith(d.TypeName));
            if (disagree != null)
            {
                var repl = node.Type.ToFullString().Replace(disagree.TypeName, disagree.ClassName);
                return base.VisitParameter(node.WithType(SyntaxFactory.ParseTypeName(repl)));
            }
            return base.VisitParameter(node);
        }

        public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
        {
            var disagree = disagreements.FirstOrDefault(d => node.Type.ToString().EndsWith(d.TypeName));
            if (disagree != null)
            {
                var repl = node.Type.ToFullString().Replace(disagree.TypeName, disagree.ClassName);
                return base.VisitPropertyDeclaration(node.WithType(SyntaxFactory.ParseTypeName(repl)));
            }
            return base.VisitPropertyDeclaration(node);
        }

        public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
        {
            var disagree = disagreements.FirstOrDefault(d => node.Type.ToString().EndsWith(d.TypeName));
            if (disagree != null)
            {
                var repl = node.Type.ToFullString().Replace(disagree.TypeName, disagree.ClassName);
                return base.VisitObjectCreationExpression(node.WithType(SyntaxFactory.ParseTypeName(repl)));
            }
            return base.VisitObjectCreationExpression(node);
        }

        public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
        {
            var disagree = disagreements.FirstOrDefault(d => node.Type.ToString().EndsWith(d.TypeName));
            if (disagree != null)
            {
                var repl = node.Type.ToFullString().Replace(disagree.TypeName, disagree.ClassName);
                return base.VisitVariableDeclaration(node.WithType(SyntaxFactory.ParseTypeName(repl)));
            }

            return base.VisitVariableDeclaration(node);
        }
    }

    public class ServiceFile
    {
        public NamespaceDeclarationSyntax Namespace { get; set; }
        public IEnumerable<CSharpSyntaxNode> Types { get; set; }

        public override string ToString()
        {
            var b = new StringBuilder(AUTO_GENERATED);

            b.Append($"namespace {Namespace.Name.ToFullString()}");
            b.AppendLine("{");

            foreach (var ty in Types)
            {
                b.Append(ty.ToFullString());
            }

            b.AppendLine("}");

            return b.ToString();
        }

        const string AUTO_GENERATED = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

"
;
    }
}
